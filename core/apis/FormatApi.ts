/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Analysis,
  Format,
  FormatReclassification,
  SeededTrackedFormatEvent,
  TrackedFormatEvent,
} from '../models/index';
import {
    AnalysisFromJSON,
    AnalysisToJSON,
    FormatFromJSON,
    FormatToJSON,
    FormatReclassificationFromJSON,
    FormatReclassificationToJSON,
    SeededTrackedFormatEventFromJSON,
    SeededTrackedFormatEventToJSON,
    TrackedFormatEventFromJSON,
    TrackedFormatEventToJSON,
} from '../models/index';

/**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @export
 * @interface FormatAnalysisRequest
 * @typedef {FormatAnalysisRequest}
 */
export interface FormatAnalysisRequest {
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {string}
 */
format: string;
}

/**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @export
 * @interface FormatReclassifyRequest
 * @typedef {FormatReclassifyRequest}
 */
export interface FormatReclassifyRequest {
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?boolean}
 */
transferable?: boolean;
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?FormatReclassification}
 */
formatReclassification?: FormatReclassification;
}

/**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @export
 * @interface FormatSnapshotRequest
 * @typedef {FormatSnapshotRequest}
 */
export interface FormatSnapshotRequest {
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {string}
 */
format: string;
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?boolean}
 */
transferable?: boolean;
}

/**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @export
 * @interface FormatUpdateValueRequest
 * @typedef {FormatUpdateValueRequest}
 */
export interface FormatUpdateValueRequest {
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?boolean}
 */
transferable?: boolean;
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?Format}
 */
format?: Format;
}

/**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @export
 * @interface FormatUsageEventRequest
 * @typedef {FormatUsageEventRequest}
 */
export interface FormatUsageEventRequest {
    /**
 * ${1:Description placeholder}
 * @date 4/12/2024 - 4:03:12 AM
 *
 * @type {?SeededTrackedFormatEvent}
 */
seededTrackedFormatEvent?: SeededTrackedFormatEvent;
}

/**
 *
 */
export class FormatApi extends runtime.BaseAPI {

    /**
     * This will get an analysis from a format\'s id.
     * /format/{format}/analysis [GET]
     */
    async formatAnalysisRaw(requestParameters: FormatAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Analysis>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling formatAnalysis.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/format/{format}/analysis`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
    }

    /**
     * This will get an analysis from a format\'s id.
     * /format/{format}/analysis [GET]
     */
    async formatAnalysis(requestParameters: FormatAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Analysis> {
        const response = await this.formatAnalysisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint will be used to reclassify a single Format.
     * /format/reclassify [POST]
     */
    async formatReclassifyRaw(requestParameters: FormatReclassifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Format>> {
        const queryParameters: any = {};

        if (requestParameters.transferable !== undefined) {
            queryParameters['transferable'] = requestParameters.transferable;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/format/reclassify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FormatReclassificationToJSON(requestParameters.formatReclassification),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
    }

    /**
     * This endpoint will be used to reclassify a single Format.
     * /format/reclassify [POST]
     */
    async formatReclassify(requestParameters: FormatReclassifyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Format> {
        const response = await this.formatReclassifyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a snapshot of a specific format.
     * /format/{format} [GET] Scoped to Format
     */
    async formatSnapshotRaw(requestParameters: FormatSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Format>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling formatSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.transferable !== undefined) {
            queryParameters['transferable'] = requestParameters.transferable;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/format/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
    }

    /**
     * Get a snapshot of a specific format.
     * /format/{format} [GET] Scoped to Format
     */
    async formatSnapshot(requestParameters: FormatSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Format> {
        const response = await this.formatSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will update a format\'s value, ie, a formats fragment or file depending on what is provided.  code/text fragment behavior: If this format is an asset.preview.base we will update the asset.original\'s value. if this format is an asset.preview.original we will update the asset.preview.base\'s value.  code/text file behavior: If the the format that is update is the asset.preview.base is a fragment and the asset.original is file then we will update the asset.original\'s value to be bytes or string respectively. This goes the same for orignal to preview but will be go the reverse order so if the original is a file we will update the preview base\'s fragment string.  image fragment/file: We will not modify preview -> orignal or original -> preview here. so there are zero side effects in this case, and will update as normal. (this will be the case for all other value updates.)
     * [POST] /format/update/value
     */
    async formatUpdateValueRaw(requestParameters: FormatUpdateValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Format>> {
        const queryParameters: any = {};

        if (requestParameters.transferable !== undefined) {
            queryParameters['transferable'] = requestParameters.transferable;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/format/update/value`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FormatToJSON(requestParameters.format),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
    }

    /**
     * This will update a format\'s value, ie, a formats fragment or file depending on what is provided.  code/text fragment behavior: If this format is an asset.preview.base we will update the asset.original\'s value. if this format is an asset.preview.original we will update the asset.preview.base\'s value.  code/text file behavior: If the the format that is update is the asset.preview.base is a fragment and the asset.original is file then we will update the asset.original\'s value to be bytes or string respectively. This goes the same for orignal to preview but will be go the reverse order so if the original is a file we will update the preview base\'s fragment string.  image fragment/file: We will not modify preview -> orignal or original -> preview here. so there are zero side effects in this case, and will update as normal. (this will be the case for all other value updates.)
     * [POST] /format/update/value
     */
    async formatUpdateValue(requestParameters: FormatUpdateValueRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Format> {
        const response = await this.formatUpdateValueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This is an analytics endpoint that will enable us to know when a user has copied/downloaded/beamed/viewed a format.
     * /format/usage/event [POST] Scoped to Format
     */
    async formatUsageEventRaw(requestParameters: FormatUsageEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrackedFormatEvent>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/format/usage/event`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SeededTrackedFormatEventToJSON(requestParameters.seededTrackedFormatEvent),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrackedFormatEventFromJSON(jsonValue));
    }

    /**
     * This is an analytics endpoint that will enable us to know when a user has copied/downloaded/beamed/viewed a format.
     * /format/usage/event [POST] Scoped to Format
     */
    async formatUsageEvent(requestParameters: FormatUsageEventRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrackedFormatEvent> {
        const response = await this.formatUsageEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
